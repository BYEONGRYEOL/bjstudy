

티켓을 구매하거나 리롤할 수 있음

같은 티켓 3개 → 황금 티켓 1개

리롤 시 다음 상점 상태를 알 수 있음 (예측됨)

목표: 주어진 금액으로 황금 티켓을 최대한 많이 얻는 것

🎯 1. 탐색(완전탐색 / DFS / 백트래킹)으로 진행할 경우 단점
🔻 ① 탐색 공간이 폭발적으로 커짐
상점 진열 수 m가 작아도, 각 상점에서 살지 말지 결정 + 리롤 타이밍까지 포함되면 상태 수가 많아짐

리롤 횟수는 최대 n-1회 → 총 n개의 shop 상태 고려

각 shop 상태에서 가능한 구매 조합 = O(2^m) (티켓 개수마다 구매 여부 선택)

결국 탐색 공간 ≈ O(n × 2^m × 상태 수) → 시간초과 위험

🔻 ② 탐색 과정 중 중복 상태가 발생
같은 조합의 티켓을 같은 비용으로 얻는 경우가 생기지만, 탐색 방식에서는 그걸 감지하기 어려움

예: A 3개, B 3개를 모은 방법이 여러 갈래일 수 있음

🔻 ③ 현실적인 최적화 기준이 없음
“언제 리롤할지”를 판단하는 기준이 명확하지 않음

“현재 티켓을 살지 말지”를 결정할 때 미래를 고려해야 함 → 이건 탐색으로는 어렵고, DP or Greedy의 판단 기준이 더 적합

✅ 2. GREEDY가 적절한 이유 (문제에서 의도한 방식)
🔸 리롤은 고정 비용 (10)
따라서, "리롤할 가치가 있는지?"를 계산할 수 있음

🔸 각 상점 상태를 보면, 3개 이상 살 수 있는 티켓 종류가 곧 황금 티켓 1개로 직결됨
목표는 티켓 종류별 개수를 3개 단위로 맞추는 것

이걸 위해 각 리롤 상태별로 구매 가능한 티켓을 선택 → 자금 소모를 최소화하는 조합 선택

🔸 결국 문제는:
최대 황금 티켓을 만들기 위해

각 리롤 상태별로 “필요한 티켓 3개를 구매하는 최소 비용 조합”을 선택

총 비용이 money 이하가 되도록 계획

💡 탐색보다 더 좋은 방법이 있는가?
👉 동적 계획법(DP) 혹은 Branch & Bound로 확장 가능
상태: (현재 money, 현재 리롤 index, 티켓 종류별 보유 개수)

목표: 황금 티켓 수 최대화

DP로 메모이제이션하면 완전탐색보다 낫지만, 상태 공간이 큼

👉 Integer Linear Programming (ILP) 모델링 가능
목적함수: 황금 티켓 수 최대화

제약조건:

자금 제한

각 리롤 상태별로 살 수 있는 수 제한

실제로는 Knapsack 문제의 확장판 형태

하지만 구현 난이도와 시간 복잡도 고려 시 Greedy가 실용적

✍️ 결론
방식	장점	단점
탐색 (DFS/백트래킹)	완전한 정답 보장	시간복잡도 큼, 불필요한 중복 탐색 많음
DP	상태 저장 가능	상태가 많아 메모리/속도 이슈
Greedy (문제 의도)	빠름, 실전 적용 쉬움	항상 최적 보장은 어려울 수 있음 (하지만 이 문제에선 가능)
ILP / 최적화 기법	수학적으로 최적	구현 복잡, 오버엔지니어링 가능성